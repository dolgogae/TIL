package com.sihun;

// 절차적 언어의 아쉬운 점
// 1. 데이터 묶음 지을수 없다.
// 2. 데이터가 많아지면 관리가 힘듦 -> 실수할 여지가 증가
// 구조체의 한계
// 데이터와 동작이 분리되어 있음. -> 파일 단위로 분리하는 법이 있음.

// OOP는 기계처럼이 아니라 사람처럼 생각하자는 운동
// 하지만 '사람처럼'이라는 말 자체가 매우 주관적
// 사회와 기술이 발전함에 따라 사람들이 사고방식도 변함

// 객체
// 1. 개체란 서로 연관 있는 상태와 동작을 가지고 있다.
// 2. 사람들은 기본적으로 세상을 객체들의 모음으로 본다.
// OOP의 특성중 캡슐화에 해당한다.

// OOP의 3대 특성
// 캡슐화, 상속, 다형성
// + 7대 개념
// 추상화, 연관, 컴포지션, 집합

// 캡슐화
// 데이터와 그 데이터에 작용하는 메서드를 하나로 묶음
// 정보 숨기기: 객체 안에 있는 데이터를 외부로부터 보호

// 상속
// 이미 존재하는 객체(엄밀히 클래스)를 기반으로 확장된 개체를 만드는 방법
// 확장된 객체: 기존의 객체에 속한 데이타와 동작을 모두 물려받음
// 실용적인 용도: 코드 중복을 막음

// 다형성
// 같은 지시를 내렸는데 다른 종류의 객체가 동작을 달리하는 것
// 어떤 함수 구현이 실행될지는 실행중에 결정됨
// 일반적인 함수 호출은 정적 바인딩(early binding)
// 다형성의 혜택을 받으려면 상속 관계가 필요
// 다른 종류의 객체를 편하게 저장 및 처리 기능

// early binding - 정적 바인딩
// 컴파일러 시간에 변수의 크기를 정할 수 있는 것

// late binding - 동적 바인딩
// 프로그램이 실행되어야 메모리에 크기가 얼마만큼 할당되는지 알 수 있게 되는 것

// 다른 형태의 다형성 - 참고: 업계에서 다형성이라고 안부르기도 함.
// 애드혹(ad-hoc) 다형성: 오버로딩
// 매개변수 다형성

// 추상화
// 수학: 일반화
// OOP: 객체 속에 있는 실제 데이터나 함수 구현 방법에 종속되지 않겠다는 뜻
// 데이터 추상화: 객체 사용시 그 안에 정확히 어떤 데이터가 있는지 알 필요 없음
//              객체 안에 있는 데이터에 직접 접근 불가
// 추상화: 다형성을 통한 추상화 - 추상클래스나 인터페이스 사용

// 연관
// 어떤 객체가 제공하는 기능을 다른 객체가 이용하는 관계
// 세부적으로 집합과 컴포지션으로 나누기도 함 - 구분하지 않고 컴포지션이라고 부르기도함

// 컴포지션
// 여러개의 부품(그 자체로 개체)을 조립해서 새 객체를 만드는 방법
// 집합과 차이: 부품 그 자체로는 존재 의의가 없음
//              조립품이 소멸할 때 부품도 같이 소멸.

// 집합
// 여러 객체를 모아 다른 객체를 만들지만 별도로도 존재 가능
// 컴포지션과 차이: 각 객체들이 따로따로 살아남을 수 있음
public class Section3 {
    public static void main(String[] args) {

    }
}
