# Spring

## 제어의 역전(Inversion of Control)
클라이언트가 직접 생성을 제어하는 것이 아닌 외부에서 제어를 하는 것.  
이렇게 함으로써 하나의 로직이 구체적인 클래스에 종속되지 않을 수 있다.

## 의존관계 주입(Dependency Injection)
현재 내가 어떤 객체가 주입될지 객체 입장에서는 모른다.  
정적인 클래스 의존관계와 동적인 클래스 의존관계를 분리해야한다.
> 정적인 의존관계: 실행전에도 알 수 있다. 어떤 객체가 어떤 객체를 참조하고 있는지.. 등등
> 동적인 의존관계: 실행전에 알 수 없다. -> 주입 받는 객체
주입을 하는 객체를 보고 DI Container라고 한다.(어셈블러, 오브젝트 팩토리)

## ApplicationContext
스프링 컨테이너라고 한다.
### AnnotationApplicationContext
ApplicationContext의 구현체로 어노테이션 기반으로 스프링 컨테이너를 생성한다.  
@Bean을 모두 호출을 한다. 그리고 스프링 빈 저장소에 저장이 된다. 항상 다른 이름으로 부여해야 한다. 이후에 동적인 의존관계를 넣어주게 된다.  

## 스프링 빈과 자식관계
부모타입으로 조회하면 자식 빈들은 같이 조회가 된다.

## BeanFactory
스프링 컨테이너의 최상위 인터페이스이다.  
빈의 관리기능과 부가기능을 제공해준다.

## BeanDefinition
역할과 구현을 개념적으로 잘 나눈 것이다.  


---
## Static Bean

스프링 컨테이너를 기본적으로 싱글톤 패턴을 이용해서 생성하기 때문에 중복 생성에 대한 걱정이 없다.

new를 중복 호출하더라도 미리 인스턴스가 있으면 new를 실행하지 않는다.  
> @Configuration에서 이 기능을 해준다.  

# 컴포넌트 스캔과 의존관계 자동 주입 시작 

## @ComponentScan
Spring은 자동으로 빈을 등록해주는 기능이 있다.  
@Compoenet를 이용해서 자동으로 빈으로 등록해준다. 그 과정에서 DI가 필요한 경우 @Autowired를 붙혀준다.
> 생성자에 Autowired가 붙으면 같은 type으로 빈에서 조회를 한다.  

### 충돌
수동 등록 빈이 자동 등록 빈보다 우선순위를 갖는다. Spring boot는 수동 등록 빈과 자동 등록 빈의 이름이 같다면 오류를 나도록 했다.

## 생성자 주입 선택하기
대부분의 의존관계는 애플리케이션 종료까지 변하면 안된다.  
생성자 주입은 객체를 생성할 때 딱 한번 호출되므로 불변하게 설계할 수 있다.  
프레임워크에 의존하지 않을수 있다.

## 조회할 빈이 2개 이상일 때

### @Autowired 매칭 정리
1. 타입 매칭
2. 타임 매칭의 결과가 2개 이상일 때, 필드 명 또는 파라미터 명으로 빈 이름 매칭

### @Qualifier
구분할 수 있는 옵션을 하나 더 제공하는 것.  
Qualifier는 해당 용도로만 사용한다.

### @Primary
스프링 빈의 우선순위를 갖게 된다.  

## 수동 등록 빈 사용 경우
1. 업무 로직 빈: 데이터 계층의 로직을 처리하는 리포지토리들이 모두 업무 로직이다. 보통 비즈니스 요구사항을 개발할때 추가되거나 변경된다.
2. 기술 지원 빈: 기술적인 문제나 공통 관심사(AOP)를 처리할 때 주로 사용된다. 데이터베이스 연결이나, 공통 로그 처리처럼 업무 로직을 지원하기 위한 하부 기술이나 공통의 기술

> 필요한 것을 한눈에 보기 쉽게 만들때,  
> 예를 들어, 어떤 할인 정책이 있는지 알고 싶을 때 한곳에 모여있으면 파악이 쉽다.

## 빈 생명주기 콜백 시장
객체생성 -> 의존 관계 주입.  
초기화 작업은 모든 의존 관계 주입이 완료된 후에 진행해야 한다.  
스프링은 콜백 메서드를 통해서 초기화 시점을 알려주는 기능이 있다.

> 스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존관계 주입 -> **초기화 콜백** -> 사용 -> 소멸전 콜백 -> 스프링 종료

---
#### **참고**
**객체의 생성과 초기화를 분리하자!**  
생성자는 메모리 할당. 초기화는 무거운 작업을 진행한다.  
따라서, 초기화의 경우에는 분리해야 유지보수하기에 좋다.  
초기화에 대한 동작을 필요할 때 사용하도록 지연시키는 것이 가능하다.
---

1. 인터페이스를 사용하는 방법 (Implements InitializingBean, DisposableBean)
단점. Spring에 의존적이며, 수정하기 어려움

2. Bean초기화시에 하는 방법
메서드 이름을 자유롭게 사용할 수 있다.  
설정정보를 사용하기 때문에 코드를 고칠 수 있는 외부 라이브러리도 초기화 가능.

> destory method의 특별한 기능.  
> close, shutdown라는 이름을 자동으로 호출한다.

@PostConstruct @PreDestroy를 이용하면 Bean에 따로 변수를 넣지 않아도 자동 동작한다.
단점. 외부 라이브러리 수정이 어렵다.