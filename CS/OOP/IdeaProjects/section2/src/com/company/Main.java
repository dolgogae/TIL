package com.company;
/**
 * 패키지
 * 연관된 클래스끼리 묶는 기법이다.
 * C#의 namespace와 비슷한 개념
 *
 * 자바 built-in 패키지
 * 자바가 기본으로 제공하는 패키지
 *
 * user-define 패키지
 * 사용자가 만든 패키지
 *
 * 목적: 이름 충돌 문제를 피할 수 있게 해줌
 * -> 패키지 이름의 중복을 최소화해야 한다.
 *
 * 패키지는 파일까지의 경로를 모두 적어주어야 한다.(패키지 명만 적으면 안된다.)
 *
 * 기존 패키지 시스템의 한계
 * 애플리케이션이 사용하는 클래스 목록을 찾는 공식적인 방법이 없음
 * - 누락된 클래스가 있다면 실행중 그것을 사용하려 할때 오류 발생
 * - 따라서 사용중인 패키지에 있는 모든 클래스를 같이 배포하는 게 일반적
 * 문제점
 * -> java 버전이 증가함에 따라 Java자체 제공 라이브러리 크기가 커짐
 * -> 안 사용하는 클래스까지 같이 배포할 경우 쓸데없이 용량이 커짐
 *
 * 패키지 안에 있는 모든 public 클래스를 아무나 사용할 수 있음.
 * 때로는 일부만 노출하고 싶음
 */

import java.util.Random;


// 파일 하나당 public class는 하나만 들어가야 한다.
// 내포 클래스는 public이 들어가 있어도 된다.
public class Main {

    public static void main(String[] args) {
	// write your code here
        Random rand = new Random();
        System.out.println("Random number: "+rand.nextInt(50));
        /**
         * System은 class이고 out은 정적 멤버 변수(PrintStream)
         * println은 out의 메서드 중 하나.
         * printf로도 사용이 가능하다.(C/C++과 동일)
         * printf는 보통 가변인자를 사용해서 출력을 한다.
         * public PrintStream printf(String format, Object... args);
         * - Object는 모든 자료형의 부모
         */

    }
}

/**
 * 컴파일
 * class 폴더 밑에 컴파일 한 결과물들이 생긴다.
 * 컴파일: javac -d <컴파일 결과물을 저장할 곳> <컴파일할 .java 파일>
 * 실행: java -classpath [class 파일 위치] [클래스 이름]
 *
 * 배포 방법
 * .jar 파일을 만듦 -> lib폴더에서 만드는 것이 일반적
 *
 * jar 생성: jar [option] [jar 파일 이름] [최상위 패키지 경로]
 * - option: c(create), f(만들어질 이름), m(menifest)
 *
 * Menifest 파일
 * 자바 애플리케이션의 정보를 담고 있는 메타데이터 파일
 * 메인함수에 대한 정보를 넣어야 한다.
 */


/**
 * java는 크로스 플랫폼
 * 특정 언어로 작성한 코드를 여러 플랫폼에서 실행할 수 있다는 의미
 *
 * 전통적인 컴파일 방법
 * 컴파일을 하면 실행 파일이 나온다.
 * 실행 파일은 기계어이며 운영체제가 직접 실행하는 파일
 * 각 운영체제/ 디바이스에서 실행파일을 따로 만들어야 함.
 *
 * 자바의 컴파일 모델
 * 코드를 컴파일 한 결과는 바이트 코드
 * 실행파일이 아님
 *
 *  바이트 코드란?
 *  운영체제/디바이스가 이해하는 기계어가 아님
 *  JVM이라는 특수한 프로그램이 이해하는 명령어
 *  JVM이 실행 중 최종 플랫폼에 맞는 명령어로 바꿔서 실행
 *  JVM에 맞게 최적화 -> 기계어보다는 속도 느림.
 *
 *  JVM이 바이트 코드를 실제 디바이스에서 실행하는 방식은 다양
 *  과거 JVM은 인터프리터 방식으로 동작
 *  최신 JVM은 JIT(just in time) 컴파일을 추가
 *  여러가지 컴파일 방식이 공존하는 형태
 */

/**
 * java에 unsigned 자료형이 없을때 생긴 문제
 * 음수가 존재하지 않는 변수(예: age)에 대해서 예외처리를 해줘야 한다. => 코드가 방어적으로 작성하게 된다.
 *
 * Integer 클래스를 통해서 해결하려고 했다.
 */

/**
 * String
 * 연속된 문자를 표현하는 클래스형
 * 클래스는 언제나 참조형이다.
 * 한번 만들면 변경이 불가능하다.(immutable)
 *
 * 리터럴
 * L: long
 * 0x: 16진수
 * 0b: 2진수
 * 0: 8진수
 * F: float
 * D: double
 * null: 참조형에 사용 가능
 * _: 숫자에 가독성을 높이기 위해서 사용한다.
 *
 * final: 상수형 변수
 * 변수값의 변경을 금지
 * 생성자에서 초기화 해주거나 선언된 메서드안에서 초기화를 해주는 것이 가능하다.
 */

/**
 * javadoc 주석
 * 현재 쓰고 있는 주석이다.
 * 문서 만들기에 매우 편리하다.
 *
 * 대입연산자
 * 일반 자료형(int, float 등)은 값을 대입한다.
 * 참조형일 경우 주소를 복사한다.(얕은복사)
 * String도 기본적을 참조형이라서 얕은 복사를 한다.
 *
 * == 연산자 주의사항
 * 참조형은 주소를 복사하기 때문에 == 얕은 복사를 한 것들이 같다고 나온다.
 * String은 같은 문자열을 넣을때 새로 new를 생성하지 않고 기존에 생성된 것의 주소를 넣어주게 된다.
 * 따라서 String name = "abc"; String name2 = "abc"; 는 같은 주소이다.
 * ex) string constant pool / string pool
 * 문자열 자체를 비교하려면 equals()를 이용해서 비교해주어야 한다.
 * (C계열 언어는 연산자 오버로딩이 가능하기 때문에 이런 개념이 없다. 유일하게 String +, += 연산자는 제공을 한다.)
 */

/**
 * 라벨
 * loof를 탈출할때 편리하다.
 * loof_exit:
 * for(~~){
 *     for(~~){
 *         break loof_exit;
 *     }
 * }
 */

/**
 * final 참조형 매개변수
 * 참조형은 주소를 넘기기 때문에 그 안에 값을 바꾸는 것은 가능하다.
 * 하지만 주소를 바꾸는 것은 불가능하기 때문에 다른 객체를 넣는 것은 불가능하다.
 *
 * java의 다차원 배열은 C의 포인터 배열처럼 배열을 넣을 수 있는 주소를 제공하는 것이다.
 * 하지만 다차원 배열처럼 사용이 가능하다.
 *
 * enum
 * java의 열거형은 바로 대입이 불가능하다.
 */

/**
 * 람다
 * (매개변) -> {표현식}
 *
 * 모듈
 * 정말 필요한 패키지만 포함할 수 있음(경량화)
 * 프로그램 시작 시 누락된 모듈을 확인 가능
 * 어떤 모듈이 사용하는 다른 모듈 목록을 찾기 쉬움
 * 모듈 사용자에게 공개할 클래스를 특정할 수 있음수
 */

